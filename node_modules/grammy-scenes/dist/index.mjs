// src/monkey_patches/composer_do.ts
import { Composer } from "grammy";
Composer.prototype.do = function(middleware) {
  this.use(async (ctx, next) => {
    await middleware(ctx, async () => void 0);
    return next();
  });
};

// src/monkey_patches/composer_setup.ts
import { Composer as Composer2 } from "grammy";
Composer2.prototype.setup = function(setup) {
  setup(this);
  return this;
};

// src/monkey_patches/composer_resume.ts
import { Composer as Composer3 } from "grammy";
Composer3.prototype.resume = function(...middleware) {
  const typedThis = this;
  return typedThis.filter(filterResume, ...middleware);
};

// src/scene.ts
import { Composer as Composer4 } from "grammy";
var Scene = class extends Composer4 {
  constructor(id) {
    super();
    this.id = id;
    this.steps = [];
    this.pos_by_label = {};
  }
  use(...middleware) {
    const composer = super.use(...middleware);
    this.steps.push(composer);
    return composer;
  }
  always(...middleware) {
    var _a;
    (_a = this._always) != null ? _a : this._always = new Composer4();
    this._always.use(...middleware);
    return this._always;
  }
  arg(arg) {
    this.do((ctx) => {
      ctx.scene.next_arg = arg;
    });
  }
  wait(...middleware) {
    this.use((ctx) => {
      ctx.scene.wait();
    });
    return this.mustResume(...middleware);
  }
  mustResume(...middleware) {
    const composer = new Composer4((ctx, next) => {
      ctx.scene.mustResume();
      return next();
    }, ...middleware);
    this.steps.push(composer);
    return composer;
  }
  call(sceneId, arg) {
    this.do((ctx) => ctx.scene.call(sceneId, arg));
  }
  exit(arg) {
    this.do((ctx) => ctx.scene.exit(arg));
  }
  goto(label, arg) {
    this.do((ctx) => ctx.scene.goto(label, arg));
  }
  label(label) {
    this.pos_by_label[label] = this.steps.length;
  }
  middleware() {
    throw Error(`Scene is not supposed to be used directly as a middleware.`);
    return super.middleware();
  }
};
function filterResume(ctx) {
  var _a, _b;
  return ((_b = (_a = ctx.scene) == null ? void 0 : _a.opts) == null ? void 0 : _b.resume) === true;
}

// src/scene_manager.ts
import { v4 as uuid_v4 } from "uuid";
var SceneManager = class {
  constructor(frame, opts) {
    this.frame = frame;
    this.opts = opts;
    this.next_arg = void 0;
    this._want_wait = false;
    this._must_resume = false;
    this._want_resume = false;
  }
  get session() {
    return this.frame.context;
  }
  set session(value) {
    this.frame.context = value;
  }
  get arg() {
    var _a;
    return (_a = this.opts) == null ? void 0 : _a.arg;
  }
  wait() {
    this._want_wait = true;
  }
  mustResume() {
    this._must_resume = true;
  }
  resume() {
    this._want_resume = true;
  }
  goto(label, arg) {
    this._want_goto = { label, arg };
  }
  exit(arg) {
    this._want_exit = { arg };
  }
  call(sceneId, arg) {
    this._want_call = { scene_id: sceneId, arg };
  }
  enter(sceneId, arg) {
    this._want_enter = { scene_id: sceneId, arg };
  }
  createResumeToken() {
    const token = uuid_v4();
    this.frame.token = token;
    return token;
  }
};

// src/scenes_composer.ts
import { assert } from "ts-essentials";
var ScenesComposer = class {
  constructor(...scenes) {
    this.scenes = {};
    for (const scene of scenes) {
      this.scene(scene);
    }
  }
  scene(scene) {
    assert(!this.scenes[scene.id], `Scene ${scene.id} already registered.`);
    this.scenes[scene.id] = scene;
  }
  manager() {
    const mw = (ctx, next) => {
      const writable_ctx = ctx;
      writable_ctx.scenes = new ScenesManager(ctx, this.scenes);
      return next();
    };
    return mw;
  }
  middleware() {
    const mw = async (ctx, next) => {
      var _a;
      const stack = (_a = ctx.session.scenes) == null ? void 0 : _a.stack;
      if (stack) {
        await ctx.scenes._run_stack(stack);
      } else {
        return next();
      }
    };
    return mw;
  }
};

// src/scenes_manager.ts
import { Composer as Composer5 } from "grammy";
import { assert as assert2 } from "ts-essentials";
var ScenesManager = class {
  constructor(ctx, scenes) {
    this.ctx = ctx;
    this.scenes = scenes;
  }
  async enter(sceneId, arg) {
    const scene = this.scenes[sceneId];
    assert2(scene, `Scene ${sceneId} not found.`);
    await this._run_stack([{ scene: sceneId, pos: 0 }], { arg });
  }
  async abort() {
    this.ctx.session.scenes = void 0;
  }
  async resume(token, arg) {
    var _a, _b;
    const stack = (_a = this.ctx.session.scenes) == null ? void 0 : _a.stack;
    if (stack && token && ((_b = stack[0]) == null ? void 0 : _b.token) === token) {
      await this._run_stack(stack, { arg, resume: true });
    }
  }
  async _run_stack(stack, opts) {
    var _a, _b, _c, _d;
    this.ctx.session.scenes = void 0;
    while (stack[0]) {
      const frame = stack[0];
      const scene = this.scenes[frame.scene];
      assert2(scene);
      const step_composer = scene.steps[frame.pos];
      let finished;
      if (step_composer) {
        const composer = new Composer5();
        if (scene._always) {
          composer.use(scene._always);
        }
        composer.use(step_composer);
        const handler = composer.middleware();
        const inner_ctx = this.ctx;
        const scene_manager = new SceneManager(frame, opts);
        opts = void 0;
        inner_ctx.scene = scene_manager;
        try {
          finished = false;
          await handler(inner_ctx, async () => {
            finished = true;
          });
        } finally {
          delete inner_ctx.scene;
        }
        if (scene_manager._want_enter) {
          const { scene_id, arg } = scene_manager._want_enter;
          stack = [{ scene: scene_id, pos: 0 }];
          opts = { arg };
          continue;
        } else if (scene_manager._want_exit) {
          const { arg } = scene_manager._want_exit;
          opts = { arg };
        } else if (scene_manager._want_goto) {
          const { label, arg } = scene_manager._want_goto;
          const pos = scene.pos_by_label[label];
          assert2(pos !== void 0, `Scene ${scene.id} doesn't have label ${label}.`);
          frame.pos = pos;
          opts = { arg };
          continue;
        } else if (scene_manager._want_call) {
          const { scene_id, arg } = scene_manager._want_call;
          frame.pos++;
          stack.unshift({ scene: scene_id, pos: 0 });
          opts = { arg };
          continue;
        } else if (scene_manager._must_resume) {
          if (scene_manager._want_resume) {
            delete frame.token;
            frame.pos++;
            continue;
          } else {
            (_b = (_a = this.ctx.session).scenes) != null ? _b : _a.scenes = { stack };
            return;
          }
        } else if (scene_manager._want_wait) {
          frame.pos++;
          (_d = (_c = this.ctx.session).scenes) != null ? _d : _c.scenes = { stack };
          return;
        } else if (finished) {
          frame.pos++;
          opts = { arg: scene_manager.next_arg };
          continue;
        } else {
          return;
        }
      }
      stack.shift();
    }
  }
};
export {
  Scene,
  SceneManager,
  ScenesComposer,
  ScenesManager,
  filterResume
};
//# sourceMappingURL=index.mjs.map