var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Scene: () => Scene,
  SceneManager: () => SceneManager,
  ScenesComposer: () => ScenesComposer,
  ScenesManager: () => ScenesManager,
  filterResume: () => filterResume
});

// src/monkey_patches/composer_do.ts
var import_grammy = require("grammy");
import_grammy.Composer.prototype.do = function(middleware) {
  this.use(async (ctx, next) => {
    await middleware(ctx, async () => void 0);
    return next();
  });
};

// src/monkey_patches/composer_setup.ts
var import_grammy2 = require("grammy");
import_grammy2.Composer.prototype.setup = function(setup) {
  setup(this);
  return this;
};

// src/monkey_patches/composer_resume.ts
var import_grammy3 = require("grammy");
import_grammy3.Composer.prototype.resume = function(...middleware) {
  const typedThis = this;
  return typedThis.filter(filterResume, ...middleware);
};

// src/scene.ts
var import_grammy4 = require("grammy");
var Scene = class extends import_grammy4.Composer {
  constructor(id) {
    super();
    this.id = id;
    this.steps = [];
    this.pos_by_label = {};
  }
  use(...middleware) {
    const composer = super.use(...middleware);
    this.steps.push(composer);
    return composer;
  }
  always(...middleware) {
    var _a;
    (_a = this._always) != null ? _a : this._always = new import_grammy4.Composer();
    this._always.use(...middleware);
    return this._always;
  }
  arg(arg) {
    this.do((ctx) => {
      ctx.scene.next_arg = arg;
    });
  }
  wait(...middleware) {
    this.use((ctx) => {
      ctx.scene.wait();
    });
    return this.mustResume(...middleware);
  }
  mustResume(...middleware) {
    const composer = new import_grammy4.Composer((ctx, next) => {
      ctx.scene.mustResume();
      return next();
    }, ...middleware);
    this.steps.push(composer);
    return composer;
  }
  call(sceneId, arg) {
    this.do((ctx) => ctx.scene.call(sceneId, arg));
  }
  exit(arg) {
    this.do((ctx) => ctx.scene.exit(arg));
  }
  goto(label, arg) {
    this.do((ctx) => ctx.scene.goto(label, arg));
  }
  label(label) {
    this.pos_by_label[label] = this.steps.length;
  }
  middleware() {
    throw Error(`Scene is not supposed to be used directly as a middleware.`);
    return super.middleware();
  }
};
function filterResume(ctx) {
  var _a, _b;
  return ((_b = (_a = ctx.scene) == null ? void 0 : _a.opts) == null ? void 0 : _b.resume) === true;
}

// src/scene_manager.ts
var import_uuid = require("uuid");
var SceneManager = class {
  constructor(frame, opts) {
    this.frame = frame;
    this.opts = opts;
    this.next_arg = void 0;
    this._want_wait = false;
    this._must_resume = false;
    this._want_resume = false;
  }
  get session() {
    return this.frame.context;
  }
  set session(value) {
    this.frame.context = value;
  }
  get arg() {
    var _a;
    return (_a = this.opts) == null ? void 0 : _a.arg;
  }
  wait() {
    this._want_wait = true;
  }
  mustResume() {
    this._must_resume = true;
  }
  resume() {
    this._want_resume = true;
  }
  goto(label, arg) {
    this._want_goto = { label, arg };
  }
  exit(arg) {
    this._want_exit = { arg };
  }
  call(sceneId, arg) {
    this._want_call = { scene_id: sceneId, arg };
  }
  enter(sceneId, arg) {
    this._want_enter = { scene_id: sceneId, arg };
  }
  createResumeToken() {
    const token = (0, import_uuid.v4)();
    this.frame.token = token;
    return token;
  }
};

// src/scenes_composer.ts
var import_ts_essentials = require("ts-essentials");
var ScenesComposer = class {
  constructor(...scenes) {
    this.scenes = {};
    for (const scene of scenes) {
      this.scene(scene);
    }
  }
  scene(scene) {
    (0, import_ts_essentials.assert)(!this.scenes[scene.id], `Scene ${scene.id} already registered.`);
    this.scenes[scene.id] = scene;
  }
  manager() {
    const mw = (ctx, next) => {
      const writable_ctx = ctx;
      writable_ctx.scenes = new ScenesManager(ctx, this.scenes);
      return next();
    };
    return mw;
  }
  middleware() {
    const mw = async (ctx, next) => {
      var _a;
      const stack = (_a = ctx.session.scenes) == null ? void 0 : _a.stack;
      if (stack) {
        await ctx.scenes._run_stack(stack);
      } else {
        return next();
      }
    };
    return mw;
  }
};

// src/scenes_manager.ts
var import_grammy5 = require("grammy");
var import_ts_essentials2 = require("ts-essentials");
var ScenesManager = class {
  constructor(ctx, scenes) {
    this.ctx = ctx;
    this.scenes = scenes;
  }
  async enter(sceneId, arg) {
    const scene = this.scenes[sceneId];
    (0, import_ts_essentials2.assert)(scene, `Scene ${sceneId} not found.`);
    await this._run_stack([{ scene: sceneId, pos: 0 }], { arg });
  }
  async abort() {
    this.ctx.session.scenes = void 0;
  }
  async resume(token, arg) {
    var _a, _b;
    const stack = (_a = this.ctx.session.scenes) == null ? void 0 : _a.stack;
    if (stack && token && ((_b = stack[0]) == null ? void 0 : _b.token) === token) {
      await this._run_stack(stack, { arg, resume: true });
    }
  }
  async _run_stack(stack, opts) {
    var _a, _b, _c, _d;
    this.ctx.session.scenes = void 0;
    while (stack[0]) {
      const frame = stack[0];
      const scene = this.scenes[frame.scene];
      (0, import_ts_essentials2.assert)(scene);
      const step_composer = scene.steps[frame.pos];
      let finished;
      if (step_composer) {
        const composer = new import_grammy5.Composer();
        if (scene._always) {
          composer.use(scene._always);
        }
        composer.use(step_composer);
        const handler = composer.middleware();
        const inner_ctx = this.ctx;
        const scene_manager = new SceneManager(frame, opts);
        opts = void 0;
        inner_ctx.scene = scene_manager;
        try {
          finished = false;
          await handler(inner_ctx, async () => {
            finished = true;
          });
        } finally {
          delete inner_ctx.scene;
        }
        if (scene_manager._want_enter) {
          const { scene_id, arg } = scene_manager._want_enter;
          stack = [{ scene: scene_id, pos: 0 }];
          opts = { arg };
          continue;
        } else if (scene_manager._want_exit) {
          const { arg } = scene_manager._want_exit;
          opts = { arg };
        } else if (scene_manager._want_goto) {
          const { label, arg } = scene_manager._want_goto;
          const pos = scene.pos_by_label[label];
          (0, import_ts_essentials2.assert)(pos !== void 0, `Scene ${scene.id} doesn't have label ${label}.`);
          frame.pos = pos;
          opts = { arg };
          continue;
        } else if (scene_manager._want_call) {
          const { scene_id, arg } = scene_manager._want_call;
          frame.pos++;
          stack.unshift({ scene: scene_id, pos: 0 });
          opts = { arg };
          continue;
        } else if (scene_manager._must_resume) {
          if (scene_manager._want_resume) {
            delete frame.token;
            frame.pos++;
            continue;
          } else {
            (_b = (_a = this.ctx.session).scenes) != null ? _b : _a.scenes = { stack };
            return;
          }
        } else if (scene_manager._want_wait) {
          frame.pos++;
          (_d = (_c = this.ctx.session).scenes) != null ? _d : _c.scenes = { stack };
          return;
        } else if (finished) {
          frame.pos++;
          opts = { arg: scene_manager.next_arg };
          continue;
        } else {
          return;
        }
      }
      stack.shift();
    }
  }
};
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Scene,
  SceneManager,
  ScenesComposer,
  ScenesManager,
  filterResume
});
//# sourceMappingURL=index.js.map