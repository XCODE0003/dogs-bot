import { Context, MiddlewareFn, Middleware, Composer, MiddlewareObj, SessionFlavor } from 'grammy';
import { SafeDictionary } from 'ts-essentials';

declare module "grammy" {
    interface Composer<C extends Context> {
        /** Simply put, do() is a use() which automatically calls next() */
        do(middleware: MiddlewareFn<C>): void;
    }
}

declare module "grammy" {
    interface Composer<C extends Context> {
        /**
         * Run the provided setup function against the current composer.
         *
         * See https://github.com/grammyjs/grammY/issues/163
         * */
        setup(setup: (composer: this) => void): this;
    }
}

declare module "grammy" {
    interface Composer<C extends Context> {
        /** Register some middleware for ctx.scenes.resume() calls. */
        resume(...middleware: Middleware<C>[]): Composer<C>;
    }
}

declare class Scene<C extends ScenesFlavoredContext = ScenesFlavoredContext, S = undefined> extends Composer<SceneFlavoredContext<C, S>> {
    readonly id: string;
    _always?: Composer<SceneFlavoredContext<C, S>>;
    steps: Array<Composer<SceneFlavoredContext<C, S>>>;
    pos_by_label: SafeDictionary<number>;
    constructor(id: string);
    use(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>): Composer<SceneFlavoredContext<C, S>>;
    always(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>): Composer<SceneFlavoredContext<C, S>>;
    /** Set payload for ctx.scene.arg in next step */
    arg(arg: any): void;
    /** Break scene middleware flow, wait for new updates. */
    wait(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>): Composer<SceneFlavoredContext<C, S>>;
    /** This middleware must call ctx.scene.resume() to go to the next middleware. */
    mustResume(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>): Composer<SceneFlavoredContext<C, S>>;
    /** Call nested scene, then go to the next step. */
    call(sceneId: string, arg?: any): void;
    /** Exit scene. */
    exit(arg?: any): void;
    /** Go to scene step marked with scene.label() */
    goto(label: string, arg?: any): void;
    /** Mark a named position in scene to be used by scene.goto() */
    label(label: string): void;
    middleware(): MiddlewareFn<SceneFlavoredContext<C, S>>;
}
/**
 * Predicate to filter contexts generated by ctx.scenes.resume()
 * See also composer.resume() shortcut.
 * */
declare function filterResume(ctx: SceneFlavoredContext<ScenesFlavoredContext, any>): boolean;

/** injected as ctx.scene */
declare class SceneManager<S = unknown> {
    readonly frame: SceneStackFrame;
    readonly opts?: SceneRunOpts | undefined;
    constructor(frame: SceneStackFrame, opts?: SceneRunOpts | undefined);
    /** Return session data that is local to this scene. The data will be discarded once scene completes, and persisted during nested scene calls. */
    get session(): S;
    set session(value: S);
    /** Return optional payload passed to enter(), call(), resume(), goto(), set by arg() or next_arg */
    get arg(): any;
    /** Payload for ctx.scene.arg in next step */
    next_arg: any;
    /** Break scene middleware flow, wait for new updates. */
    wait(): void;
    _want_wait: boolean;
    /** This middleware must call ctx.scene.resume() to go to the next middleware. */
    mustResume(): void;
    _must_resume: boolean;
    /** Go to the next middleware after this one completes. Used after ctx.scenes.wait() or ctx.scene.mustResume() */
    resume(): void;
    _want_resume: boolean;
    /** Go to scene step marked with scene.label() */
    goto(label: string, arg?: any): void;
    _want_goto?: {
        label: string;
        arg?: any;
    };
    /**
     * Exit scene.
     *
     * Nested scene will return to outer scene, optionally with argument.
     * */
    exit(arg?: any): void;
    _want_exit?: {
        arg?: any;
    };
    /** Call nested scene, then go to the next step. */
    call(sceneId: string, arg?: any): void;
    _want_call?: {
        scene_id: string;
        arg?: any;
    };
    /** Disregard current scenes stack, switch to a new scene. */
    enter(sceneId: string, arg?: any): void;
    _want_enter?: {
        scene_id: string;
        arg?: any;
    };
    /** Return a token that can be used later for ctx.scenes.resume() */
    createResumeToken(): string;
}
declare type SceneFlavoredContext<C extends ScenesFlavoredContext, S> = C & {
    readonly scene: SceneManager<S>;
};

declare class ScenesComposer<C extends ScenesFlavoredContext> implements MiddlewareObj<C> {
    scenes: SafeDictionary<Scene<C, any>>;
    constructor(...scenes: Scene<C, any>[]);
    scene(scene: Scene<C, any>): void;
    manager(): MiddlewareFn<C>;
    middleware(): MiddlewareFn<C>;
}

/** injected as ctx.scenes */
declare class ScenesManager<C extends ScenesFlavoredContext = ScenesFlavoredContext> {
    readonly ctx: C;
    readonly scenes: SafeDictionary<Scene<C, any>>;
    constructor(ctx: C, scenes: SafeDictionary<Scene<C, any>>);
    /** Enter top-level scene */
    enter(sceneId: string, arg?: unknown): Promise<void>;
    /** Abort scenes execution */
    abort(): Promise<void>;
    /** Resume scene if it's still on the same step */
    resume(token: string, arg?: unknown): Promise<void>;
    _run_stack(stack: SceneStackFrame[], opts?: SceneRunOpts): Promise<void>;
}
interface SceneRunOpts {
    arg?: any;
    resume?: boolean;
}

/** Flavor to grammy session */
interface ScenesSessionFlavor {
    scenes?: {
        stack: SceneStackFrame[];
    };
}
interface SceneStackFrame {
    scene: string;
    pos: number;
    context?: any;
    token?: string;
}
/** Flavor to grammy context */
declare type ScenesFlavor = {
    readonly scenes: ScenesManager;
};
/** Grammy context, flavored with scenes */
declare type ScenesFlavoredContext<C extends Context = Context> = C & SessionFlavor<ScenesSessionFlavor> & ScenesFlavor;

export { Scene, SceneFlavoredContext, SceneManager, SceneRunOpts, SceneStackFrame, ScenesComposer, ScenesFlavor, ScenesFlavoredContext, ScenesManager, ScenesSessionFlavor, filterResume };
