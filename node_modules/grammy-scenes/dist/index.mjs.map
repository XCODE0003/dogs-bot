{"version":3,"sources":["../src/monkey_patches/composer_do.ts","../src/monkey_patches/composer_setup.ts","../src/monkey_patches/composer_resume.ts","../src/scene.ts","../src/scene_manager.ts","../src/scenes_composer.ts","../src/scenes_manager.ts"],"sourcesContent":["import { Composer, Context, MiddlewareFn } from \"grammy\"\n\ndeclare module \"grammy\" {\n\tinterface Composer<C extends Context> {\n\t\t/** Simply put, do() is a use() which automatically calls next() */\n\t\tdo(middleware: MiddlewareFn<C>): void\n\t}\n}\n\nComposer.prototype.do = function <C extends Context>(\n\tthis: Composer<C>,\n\tmiddleware: MiddlewareFn<C>\n) {\n\tthis.use(async (ctx, next) => {\n\t\tawait middleware(ctx, async () => undefined)\n\t\treturn next()\n\t})\n}\n","import { Composer, Context } from \"grammy\"\n\ndeclare module \"grammy\" {\n\tinterface Composer<C extends Context> {\n\t\t/**\n\t\t * Run the provided setup function against the current composer.\n\t\t *\n\t\t * See https://github.com/grammyjs/grammY/issues/163\n\t\t * */\n\t\tsetup(setup: (composer: this) => void): this\n\t}\n}\n\nComposer.prototype.setup = function <C extends Context>(\n\tthis: Composer<C>,\n\tsetup: (composer: Composer<C>) => void\n) {\n\tsetup(this)\n\treturn this\n}\n","import { Composer, Context, Middleware } from \"grammy\"\n\nimport { filterResume, SceneFlavoredContext, ScenesFlavoredContext } from \"..\"\n\ndeclare module \"grammy\" {\n\tinterface Composer<C extends Context> {\n\t\t/** Register some middleware for ctx.scenes.resume() calls. */\n\t\tresume(...middleware: Middleware<C>[]): Composer<C>\n\t}\n}\n\nComposer.prototype.resume = function <C extends Context>(\n\tthis: Composer<C>,\n\t...middleware: Middleware<C>[]\n) {\n\tconst typedThis = this as unknown as Composer<\n\t\tSceneFlavoredContext<ScenesFlavoredContext<C>, any>\n\t>\n\treturn typedThis.filter(filterResume, ...middleware)\n}\n","import { Composer, Middleware, MiddlewareFn } from \"grammy\"\nimport { SafeDictionary } from \"ts-essentials\"\n\nimport { SceneFlavoredContext, ScenesFlavoredContext } from \".\"\n\nexport class Scene<\n\tC extends ScenesFlavoredContext = ScenesFlavoredContext,\n\tS = undefined\n> extends Composer<SceneFlavoredContext<C, S>> {\n\t_always?: Composer<SceneFlavoredContext<C, S>>\n\tsteps: Array<Composer<SceneFlavoredContext<C, S>>> = []\n\tpos_by_label: SafeDictionary<number> = {}\n\n\tconstructor(public readonly id: string) {\n\t\tsuper()\n\t}\n\n\tuse(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {\n\t\tconst composer = super.use(...middleware)\n\t\tthis.steps.push(composer)\n\t\treturn composer\n\t}\n\n\talways(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {\n\t\tthis._always ??= new Composer<SceneFlavoredContext<C, S>>()\n\t\tthis._always.use(...middleware)\n\t\treturn this._always\n\t}\n\n\t/** Set payload for ctx.scene.arg in next step */\n\targ(arg: any) {\n\t\tthis.do((ctx) => {\n\t\t\tctx.scene.next_arg = arg\n\t\t})\n\t}\n\n\t/** Break scene middleware flow, wait for new updates. */\n\twait(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {\n\t\tthis.use((ctx) => {\n\t\t\tctx.scene.wait()\n\t\t})\n\t\treturn this.mustResume(...middleware)\n\t}\n\n\t/** This middleware must call ctx.scene.resume() to go to the next middleware. */\n\tmustResume(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {\n\t\tconst composer = new Composer<SceneFlavoredContext<C, S>>((ctx, next) => {\n\t\t\tctx.scene.mustResume()\n\t\t\treturn next()\n\t\t}, ...middleware)\n\t\tthis.steps.push(composer)\n\t\treturn composer\n\t}\n\n\t/** Call nested scene, then go to the next step. */\n\tcall(sceneId: string, arg?: any) {\n\t\tthis.do((ctx) => ctx.scene.call(sceneId, arg))\n\t}\n\n\t/** Exit scene. */\n\texit(arg?: any) {\n\t\tthis.do((ctx) => ctx.scene.exit(arg))\n\t}\n\n\t/** Go to scene step marked with scene.label() */\n\tgoto(label: string, arg?: any) {\n\t\tthis.do((ctx) => ctx.scene.goto(label, arg))\n\t}\n\n\t/** Mark a named position in scene to be used by scene.goto() */\n\tlabel(label: string) {\n\t\tthis.pos_by_label[label] = this.steps.length\n\t}\n\n\tmiddleware() {\n\t\tthrow Error(`Scene is not supposed to be used directly as a middleware.`)\n\t\treturn super.middleware() // Prevent type error\n\t}\n}\n\n/**\n * Predicate to filter contexts generated by ctx.scenes.resume()\n * See also composer.resume() shortcut.\n * */\nexport function filterResume(\n\tctx: SceneFlavoredContext<ScenesFlavoredContext, any>\n) {\n\treturn ctx.scene?.opts?.resume === true\n}\n","import { v4 as uuid_v4 } from \"uuid\"\n\nimport { SceneRunOpts, ScenesFlavoredContext, SceneStackFrame } from \".\"\n\n/** injected as ctx.scene */\nexport class SceneManager<S = unknown> {\n\tconstructor(\n\t\tpublic readonly frame: SceneStackFrame,\n\t\tpublic readonly opts?: SceneRunOpts\n\t) {}\n\n\t/** Return session data that is local to this scene. The data will be discarded once scene completes, and persisted during nested scene calls. */\n\tget session() {\n\t\treturn this.frame.context as S\n\t}\n\n\tset session(value: S) {\n\t\tthis.frame.context = value\n\t}\n\n\t/** Return optional payload passed to enter(), call(), resume(), goto(), set by arg() or next_arg */\n\tget arg() {\n\t\treturn this.opts?.arg\n\t}\n\n\t/** Payload for ctx.scene.arg in next step */\n\tnext_arg: any = undefined\n\n\t/** Break scene middleware flow, wait for new updates. */\n\twait() {\n\t\tthis._want_wait = true\n\t}\n\t_want_wait = false\n\n\t/** This middleware must call ctx.scene.resume() to go to the next middleware. */\n\tmustResume() {\n\t\tthis._must_resume = true\n\t}\n\t_must_resume = false\n\n\t/** Go to the next middleware after this one completes. Used after ctx.scenes.wait() or ctx.scene.mustResume() */\n\tresume() {\n\t\tthis._want_resume = true\n\t}\n\t_want_resume = false\n\n\t/** Go to scene step marked with scene.label() */\n\tgoto(label: string, arg?: any) {\n\t\tthis._want_goto = { label, arg }\n\t}\n\t_want_goto?: { label: string; arg?: any }\n\n\t/**\n\t * Exit scene.\n\t *\n\t * Nested scene will return to outer scene, optionally with argument.\n\t * */\n\texit(arg?: any) {\n\t\tthis._want_exit = { arg }\n\t}\n\t_want_exit?: { arg?: any }\n\n\t/** Call nested scene, then go to the next step. */\n\tcall(sceneId: string, arg?: any) {\n\t\tthis._want_call = { scene_id: sceneId, arg }\n\t}\n\t_want_call?: { scene_id: string; arg?: any }\n\n\t/** Disregard current scenes stack, switch to a new scene. */\n\tenter(sceneId: string, arg?: any) {\n\t\tthis._want_enter = { scene_id: sceneId, arg }\n\t}\n\t_want_enter?: { scene_id: string; arg?: any }\n\n\t/** Return a token that can be used later for ctx.scenes.resume() */\n\tcreateResumeToken() {\n\t\tconst token = uuid_v4()\n\t\tthis.frame.token = token\n\t\treturn token\n\t}\n}\n\nexport type SceneFlavoredContext<C extends ScenesFlavoredContext, S> = C & {\n\treadonly scene: SceneManager<S>\n}\n","import { MiddlewareFn, MiddlewareObj } from \"grammy\"\nimport { assert, SafeDictionary } from \"ts-essentials\"\n\nimport { Scene, ScenesFlavoredContext, ScenesManager } from \".\"\n\nexport class ScenesComposer<C extends ScenesFlavoredContext>\n\timplements MiddlewareObj<C>\n{\n\tscenes: SafeDictionary<Scene<C, any>> = {}\n\n\tconstructor(...scenes: Scene<C, any>[]) {\n\t\tfor (const scene of scenes) {\n\t\t\tthis.scene(scene)\n\t\t}\n\t}\n\n\tscene(scene: Scene<C, any>) {\n\t\tassert(!this.scenes[scene.id], `Scene ${scene.id} already registered.`)\n\t\tthis.scenes[scene.id] = scene\n\t}\n\n\tmanager(): MiddlewareFn<C> {\n\t\tconst mw: MiddlewareFn<C> = (ctx, next) => {\n\t\t\tconst writable_ctx = ctx as any\n\t\t\twritable_ctx.scenes = new ScenesManager<C>(ctx, this.scenes)\n\t\t\treturn next()\n\t\t}\n\t\treturn mw\n\t}\n\n\tmiddleware() {\n\t\tconst mw: MiddlewareFn<C> = async (ctx, next) => {\n\t\t\tconst stack = ctx.session.scenes?.stack\n\t\t\tif (stack) {\n\t\t\t\tawait ctx.scenes._run_stack(stack)\n\t\t\t} else {\n\t\t\t\treturn next()\n\t\t\t}\n\t\t}\n\t\treturn mw\n\t}\n}\n","import { Composer } from \"grammy\"\nimport { assert, SafeDictionary } from \"ts-essentials\"\n\nimport {\n\tScene,\n\tSceneFlavoredContext,\n\tSceneManager,\n\tScenesFlavoredContext,\n\tSceneStackFrame,\n} from \".\"\n\n/** injected as ctx.scenes */\nexport class ScenesManager<\n\t// This is a public type, so we provide defaults.\n\tC extends ScenesFlavoredContext = ScenesFlavoredContext\n> {\n\tconstructor(\n\t\tpublic readonly ctx: C,\n\t\tpublic readonly scenes: SafeDictionary<Scene<C, any>>\n\t) {}\n\n\t/** Enter top-level scene */\n\tasync enter(sceneId: string, arg?: unknown) {\n\t\tconst scene = this.scenes[sceneId]\n\t\tassert(scene, `Scene ${sceneId} not found.`)\n\t\tawait this._run_stack([{ scene: sceneId, pos: 0 }], { arg })\n\t}\n\n\t/** Abort scenes execution */\n\tasync abort() {\n\t\tthis.ctx.session.scenes = undefined\n\t}\n\n\t/** Resume scene if it's still on the same step */\n\tasync resume(token: string, arg?: unknown) {\n\t\tconst stack = this.ctx.session.scenes?.stack\n\t\tif (stack && token && stack[0]?.token === token) {\n\t\t\tawait this._run_stack(stack, { arg, resume: true })\n\t\t}\n\t}\n\n\tasync _run_stack(stack: SceneStackFrame[], opts?: SceneRunOpts) {\n\t\t// By default, delete the stack from the session. Re-save it explicitly in two cases:\n\t\t//\n\t\t// 1) ctx.scene.wait()\n\t\t// 2) ctx.scene.mustResume() without ctx.scene.resume()\n\t\t//\n\t\t// Deleting the stack earlier rather than on demand allows to handle cases\n\t\t// such as entering a different scenes without finishing the first one.\n\t\tthis.ctx.session.scenes = undefined\n\n\t\twhile (stack[0]) {\n\t\t\tconst frame = stack[0]\n\t\t\tconst scene = this.scenes[frame.scene]\n\t\t\tassert(scene)\n\t\t\tconst step_composer = scene.steps[frame.pos]\n\t\t\tlet finished: boolean\n\t\t\tif (step_composer) {\n\t\t\t\tconst composer = new Composer<SceneFlavoredContext<C, any>>()\n\t\t\t\tif (scene._always) {\n\t\t\t\t\t// TODO: don't run _always middleware for the next step of the same scene\n\t\t\t\t\tcomposer.use(scene._always)\n\t\t\t\t}\n\t\t\t\tcomposer.use(step_composer)\n\t\t\t\tconst handler = composer.middleware()\n\t\t\t\tconst inner_ctx = this.ctx as any\n\t\t\t\tconst scene_manager = new SceneManager(frame, opts)\n\t\t\t\topts = undefined\n\t\t\t\tinner_ctx.scene = scene_manager\n\t\t\t\ttry {\n\t\t\t\t\tfinished = false\n\t\t\t\t\tawait handler(inner_ctx, async () => {\n\t\t\t\t\t\tfinished = true\n\t\t\t\t\t})\n\t\t\t\t} finally {\n\t\t\t\t\tdelete inner_ctx.scene\n\t\t\t\t}\n\n\t\t\t\tif (scene_manager._want_enter) {\n\t\t\t\t\tconst { scene_id, arg } = scene_manager._want_enter\n\t\t\t\t\tstack = [{ scene: scene_id, pos: 0 }]\n\t\t\t\t\topts = { arg }\n\t\t\t\t\tcontinue\n\t\t\t\t} else if (scene_manager._want_exit) {\n\t\t\t\t\tconst { arg } = scene_manager._want_exit\n\t\t\t\t\topts = { arg }\n\t\t\t\t\t// Do nothing - this will shift stack and continue.\n\t\t\t\t} else if (scene_manager._want_goto) {\n\t\t\t\t\tconst { label, arg } = scene_manager._want_goto\n\t\t\t\t\tconst pos = scene.pos_by_label[label]\n\t\t\t\t\tassert(\n\t\t\t\t\t\tpos !== undefined,\n\t\t\t\t\t\t`Scene ${scene.id} doesn't have label ${label}.`\n\t\t\t\t\t)\n\t\t\t\t\tframe.pos = pos\n\t\t\t\t\topts = { arg }\n\t\t\t\t\tcontinue\n\t\t\t\t} else if (scene_manager._want_call) {\n\t\t\t\t\tconst { scene_id, arg } = scene_manager._want_call\n\t\t\t\t\tframe.pos++\n\t\t\t\t\tstack.unshift({ scene: scene_id, pos: 0 })\n\t\t\t\t\topts = { arg }\n\t\t\t\t\tcontinue\n\t\t\t\t} else if (scene_manager._must_resume) {\n\t\t\t\t\tif (scene_manager._want_resume) {\n\t\t\t\t\t\tdelete frame.token\n\t\t\t\t\t\tframe.pos++\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// wait handler didn't ask to resume\n\t\t\t\t\t\tthis.ctx.session.scenes ??= { stack }\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else if (scene_manager._want_wait) {\n\t\t\t\t\tframe.pos++\n\t\t\t\t\tthis.ctx.session.scenes ??= { stack }\n\t\t\t\t\treturn\n\t\t\t\t} else if (finished) {\n\t\t\t\t\tframe.pos++\n\t\t\t\t\topts = { arg: scene_manager.next_arg }\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\t// Middleware didn't call next() and didn't ask to wait; stop execution.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift()\n\t\t}\n\t}\n}\n\nexport interface SceneRunOpts {\n\targ?: any\n\tresume?: boolean\n}\n"],"mappings":"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","names":[]}